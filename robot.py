#ONE POSSIBLE IMPROVEMENT INSTEAD OF USING THE WHOLE CONTENT, USE LATENT GENERATED BY CNN/GAN
import tensorflow as tf
import numpy as np
import random
from collections import deque
from tensorflow.contrib import rnn
import os
from sklearn.preprocessing import PolynomialFeatures
#os.environ['CUDA_VISIBLE_DEVICES']='0,1'  # Number of GPUs to run on
os.environ['CUDA_VISIBLE_DEVICES']='-1'

# Hyper Parameters:
GAMMA = 0.99  # decay rate of past observations
OBSERVE = 32.  # timesteps to observe before training
REPLAY_MEMORY_SIZE = 300  # number of previous transitions to remember
BATCH_SIZE = 32  # size of minibatch
FINAL_EPSILON = 0
INITIAL_EPSILON = 0.5
# or alternative:
# FINAL_EPSILON = 0.0001  # final value of epsilon
# INITIAL_EPSILON = 0.01  # starting value of epsilon
# UPDATE_TIME = 100
EXPLORE = 100000.  # frames over which to anneal epsilon



class RobotLSTMQ:

    def __init__(self, actions, features, content, poly):
        print("Creating a robot: LSTM-Q")
        # replay memory
        self.replay_memory = deque()
        self.time_step = 0.
        self.action = actions

        self.train_step = 30.
        self.content = content
        self.poly = poly
        #number of features selected
        self.n_features = len(features)
        #shape of all features
        self.features = features
        self.feature_shape = [[378,10],[257,10],[70,10],[27,10],[24,10]]
        self.epsilon = INITIAL_EPSILON
        self.expand = [15,45,91,153]
        self.create_qnetwork()
        self.saver = tf.train.Saver()

    def create_qnetwork(self):
        # read an input

        self.num_classes = 3
        self.n_hidden  = 32
        
        if self.content:
            inputs_all = 0
            for i in self.features:
                inputs_all = self.feature_shape[i][0] + inputs_all
            
            print('x shape:', self.feature_shape[0][1], inputs_all)

            self.x = tf.placeholder(
                    tf.float32, [None, self.feature_shape[i][1], inputs_all], name="input_x")
            self.state_confidence = tf.placeholder(
                    tf.float32, [None, self.n_features], name="input_confidence")
            self.predictions = tf.placeholder(
                    tf.float32, [None, self.num_classes*self.n_features], name="input_predictions")
            
            #have n_features placeholders            
            def lstm(x, weights, biases):
                x = tf.unstack(x, self.feature_shape[i][1], 1)
                with tf.variable_scope('lstm1'):
                    lstm_cell = rnn.BasicLSTMCell(self.n_hidden, forget_bias=1.0)
                with tf.variable_scope('lstm2'):
                    self.outputs, _ = rnn.static_rnn(lstm_cell, x, dtype=tf.float32)
                self.avg_outputs = tf.reduce_mean(tf.stack(self.outputs), 0)
    
                pred = tf.matmul(self.avg_outputs, weights['out']) + biases['out']
    
                return pred
            
            # network weights
            # size of a input = 10*3
            self.state_len = inputs_all
            self.weight_proj = {'out': tf.Variable(tf.random_normal([self.n_hidden, self.state_len]))}
            self.biases_proj = {'out': tf.Variable(tf.random_normal([self.state_len]))}
            self.enc_s = lstm(self.x, self.weight_proj, self.biases_proj)
            # confidence is a scalar
            self.enc_total = tf.concat((self.enc_s, self.state_confidence, self.predictions), axis=1)
            
            # size of predictive marginal distribution is 3
            with tf.variable_scope('robot'):
                self.w_fc2 = self.weight_variable([self.state_len+4*self.n_features, self.action])
                self.b_fc2 = self.bias_variable([self.action])
        else:
            if self.poly:
                self.enc_total = tf.placeholder(
                    tf.float32, [None, self.expand[self.n_features-1]], name="input_expanded")
                with tf.variable_scope('robot'):
                    self.w_fc2 = self.weight_variable([self.expand[self.n_features-1], self.action])
                    self.b_fc2 = self.bias_variable([self.action])
            else:
                self.state_confidence = tf.placeholder(
                    tf.float32, [None, self.n_features], name="input_confidence")
                self.predictions = tf.placeholder(
                    tf.float32, [None, self.n_features*self.num_classes], name="input_predictions")
                self.enc_total = tf.concat((self.state_confidence, self.predictions), axis=1)
                with tf.variable_scope('robot'):
                    self.w_fc2 = self.weight_variable([4*self.n_features, self.action])
                    self.b_fc2 = self.bias_variable([self.action])

        # Q Value layer
        self.qvalue = tf.matmul(self.enc_total, self.w_fc2) + self.b_fc2
        # action input
        self.action_input = tf.placeholder("float", [None, self.action])
        # reword input
        self.y_input = tf.placeholder("float", [None])

        q_action = tf.reduce_sum(
            tf.multiply(self.qvalue, self.action_input), reduction_indices=1)
        # error function
        self.cost = tf.reduce_mean(tf.square(self.y_input - q_action))
        # train method
        with tf.variable_scope('adam2'):
            self.trainStep = tf.train.AdamOptimizer(1e-3).minimize(self.cost)

        self.sess = tf.Session()
        # ? multiple graphs: how to initialise variables 
        self.sess.run(tf.global_variables_initializer())

    def train_qnetwork(self):
        # Step 1: obtain random minibatch from replay memory
        minibatch = random.sample(self.replay_memory, BATCH_SIZE)
        state_batch = [data[0] for data in minibatch]
        action_batch = [data[1] for data in minibatch]
        reward_batch = [data[2] for data in minibatch]
        next_state_batch = [data[3] for data in minibatch]
        next_state_sent_batch = []
        next_state_confidence_batch = []
        next_state_predictions_batch = []

        for item in next_state_batch:
            sent, confidence, predictions = item
            next_state_sent_batch.append(sent)
            # next state_sent_batch has size 
            next_state_confidence_batch.append(confidence)
            next_state_predictions_batch.append(predictions)

        # Step 2: calculate y
        #next_state_predictions_batch = np.reshape(next_state_predictions_batch, (len(next_state_sent_batch),self.n_features,3))

        for i in range(32):
            next_state_sent_batch[i] = np.concatenate((next_state_sent_batch[i]),axis=1)
        concatenate_x = np.array(next_state_sent_batch)
        
        #concatenate_x = np.array(next_state_sent_batch)[:,-1]
        concatenate_predictions = np.squeeze(next_state_predictions_batch, axis=1)


        y_batch = []
        if self.content:
            qvalue_batch = self.sess.run(self.qvalue, feed_dict={
                                     self.x: concatenate_x, self.state_confidence: next_state_confidence_batch, self.predictions: list(concatenate_predictions)})
        else:
            if self.poly:
                enc_total_in = np.concatenate((next_state_confidence_batch, list(concatenate_predictions)), axis=1)
                poly = PolynomialFeatures(2)
                expanded_enc_total_in = poly.fit_transform(enc_total_in)
                print(expanded_enc_total_in.shape)
                qvalue_batch = self.sess.run(self.qvalue, feed_dict={
                                     self.enc_total: expanded_enc_total_in})
            else:
                qvalue_batch = self.sess.run(self.qvalue, feed_dict={
                                     self.state_confidence: next_state_confidence_batch, self.predictions: list(concatenate_predictions)})
        for i in range(0, BATCH_SIZE):
            terminal = minibatch[i][4]
            if terminal:
                y_batch.append(reward_batch[i])
            else:
                y_batch.append(reward_batch[i] +
                               GAMMA * np.max(qvalue_batch[i]))
        sent_batch = []
        confidence_batch = []
        predictions_batch = []
        for item in state_batch:
            sent, confidence, predictions = item
            sent_batch.append(sent)
            confidence_batch.append(confidence)
            predictions_batch.append(predictions)
        
        #concatenate_x = np.concatenate((next_state_sent_batch[0]),axis=1)

        for i in range(32):
            sent_batch[i] = np.concatenate((sent_batch[i]),axis=1)
        concatenate = np.array(sent_batch)
        
        concatenate_predictions = np.squeeze(predictions_batch, axis=1)

        if self.content:
            
            self.sess.run(self.trainStep, feed_dict={
                      self.y_input: y_batch, self.action_input: action_batch, self.x: concatenate, self.state_confidence: confidence_batch, self.predictions:list(concatenate_predictions)})
        else:
            if self.poly:
                enc_total_in = np.concatenate((confidence_batch, list(concatenate_predictions)), axis=1)
                poly = PolynomialFeatures(2)
                expanded_enc_total_in = poly.fit_transform(enc_total_in)
                print(expanded_enc_total_in.shape)
                self.sess.run(self.trainStep, feed_dict={self.y_input: y_batch, self.enc_total: expanded_enc_total_in})
            else:
                self.sess.run(self.trainStep, feed_dict={
                      self.y_input: y_batch, self.action_input: action_batch, self.state_confidence: confidence_batch, self.predictions:list(concatenate_predictions)})
        # save network every 10000 iteration
        # if self.time_step % 10000 == 0:
        #    self.saver.save(self.sess, './' +
        #                    'network' + '-dqn', global_step=self.time_step)

    def update(self, observation, action, reward, observation2, terminal):
        self.current_state = observation
        new_state = observation2
        self.replay_memory.append(
            (self.current_state, action, reward, new_state, terminal))
        if len(self.replay_memory) > REPLAY_MEMORY_SIZE:
            self.replay_memory.popleft()
        global OBSERVE

        if self.time_step > OBSERVE and self.time_step % self.train_step == 0.0:
            # Train the network
            print('DQN-trained')
            self.train_qnetwork()

        self.current_state = new_state
        self.time_step += 1

    def get_action(self, observation):
        #print("LSTM-DQN is smart.")
        self.current_state = observation
        sent, confidence, predictions = self.current_state
        # print sent, confidence, predictions
        if self.content:
            concatenate = sent[-1]
            for i in range(self.n_features-1):
                concatenate = np.concatenate((concatenate, sent[i]),axis=1)
            qvalue = self.sess.run(self.qvalue, feed_dict={self.x: 
                               [concatenate], self.state_confidence: [confidence], self.predictions: predictions})[0]
        else:
            if self.poly:
                print(np.array([confidence]).shape)
                print(np.array(predictions).shape)
                enc_total_in = np.concatenate(([confidence], predictions), axis=1)
                poly = PolynomialFeatures(2)
                expanded_enc_total_in = poly.fit_transform(enc_total_in)
                print(expanded_enc_total_in.shape)
                qvalue = self.sess.run(self.qvalue, feed_dict={
                                     self.enc_total: expanded_enc_total_in})
            else:
                qvalue = self.sess.run(self.qvalue, feed_dict={self.state_confidence: [confidence], self.predictions: predictions})[0]
        
        action = np.zeros(self.action)
        action_index = 0
        # if self.timeStep % FRAME_PER_ACTION == 0:
        if random.random() <= self.epsilon:
            action_index = random.randrange(self.action)
            action[action_index] = 1
        else:
            action_index = np.argmax(qvalue)
            action[action_index] = 1
        # else:
        #    action[0] = 1 # do nothing

        # change episilon
        if self.epsilon > FINAL_EPSILON and self.time_step > OBSERVE:
            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / EXPLORE

        return action

    def weight_variable(self, shape):
        initial = tf.truncated_normal(shape, stddev=0.01)
        return tf.Variable(initial)

    def bias_variable(self, shape):
        initial = tf.constant(0.01, shape=shape)
        return tf.Variable(initial)

    def save_Q_network(self, model_val):
        if not os.path.exists('new_checkpoint' + os.sep + "Q_" + model_val):
            os.makedirs('new_checkpoint' + os.sep + "Q_" + model_val)
        self.saver.save(self.sess, "new_checkpoint" + os.sep + "Q_" + model_val + os.sep + 'model.ckpt')
        print('save the q network')
        
    def test_get_action(self, model_val, observation):
        ckpt = tf.train.get_checkpoint_state('checkpoint' + os.sep + "Q_" + model_val)
        self.saver.restore(self.sess, ckpt.model_checkpoint_path)
        print('load the q network')
        
        self.current_state = observation
        sent, confidence, predictions = self.current_state
        # print sent, confidence, predictions
        if self.content:
            concatenate = sent[-1]
            for i in range(self.n_features-1):
                concatenate = np.concatenate((concatenate, sent[i]),axis=1)
            qvalue = self.sess.run(self.qvalue, feed_dict={self.x: 
                               [concatenate], self.state_confidence: [confidence], self.predictions: predictions})[0]
        else:
            if self.poly:
                enc_total_in = np.concatenate(([confidence], predictions), axis=1)
                poly = PolynomialFeatures(2)
                expanded_enc_total_in = poly.fit_transform(enc_total_in)
                qvalue = self.sess.run(self.qvalue, feed_dict={
                                     self.enc_total: expanded_enc_total_in})
            else:
                qvalue = self.sess.run(self.qvalue, feed_dict={self.state_confidence: [confidence], self.predictions: predictions})[0]
        
        action = np.zeros(self.action)
        action_index = 0
        # if self.timeStep % FRAME_PER_ACTION == 0:
        if random.random() <= self.epsilon:
            action_index = random.randrange(self.action)
            action[action_index] = 1
        else:
            action_index = np.argmax(qvalue)
            action[action_index] = 1
        # else:
        #    action[0] = 1 # do nothing

        # change episilon
        if self.epsilon > FINAL_EPSILON and self.time_step > OBSERVE:
            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / EXPLORE
        
        return action